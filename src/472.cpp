#include <algorithm>
#include <cstring>
#include <iostream>
#include <unordered_set>
#include <vector>

using namespace std;

class Solution {
#define DYNAMIC_PROGRAMMING_SUBSTR (0)
#define DYNAMIC_PROGRAMMING_TRIE (1)  // valgrind: definitely lost

   private:
#if (DYNAMIC_PROGRAMMING_SUBSTR)
#elif (DYNAMIC_PROGRAMMING_TRIE)
#define MAX_CHAR (26)  // words[i] consists of only lowercase English letters.

    struct trie {
        struct trie* arr[MAX_CHAR];
        bool end = false;
        trie() {
            memset(arr, 0, sizeof(arr));
            end = false;
        }
    };
    trie* root;

    void insert(string s) {
        trie* node = root;

        // inserting the string in reverse order as we will search from the end of the word while using DP.
        for (int i = s.length() - 1; i >= 0; --i) {
            if (node->arr[s[i] - 'a'] == NULL) {
                node->arr[s[i] - 'a'] = new trie();
            }
            node = node->arr[s[i] - 'a'];
        }
        node->end = true;
    }
#endif

   public:
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        vector<string> retVal;

#if (DYNAMIC_PROGRAMMING_SUBSTR)
        cout << "DYNAMIC_PROGRAMMING_SUBSTR\n";

        unordered_set<string> hashTable(words.begin(), words.end());
        for (auto word : words) {
            int len = word.length();
            vector<bool> dp(len + 1);
            dp[0] = true;

            for (int i = 1; i <= len; ++i) {
                for (int j = (i == len ? 1 : 0); j < i; ++j) {
                    if (dp[i] == true) {
                        break;
                    }
                    dp[i] = dp[j] && hashTable.count(word.substr(j, i - j));
                }
            }

            if (dp[len] == true) {
                retVal.push_back(word);
            }
        }
#elif (DYNAMIC_PROGRAMMING_TRIE)
        // https://leetcode.com/problems/concatenated-words/solutions/1401307/accepted-192ms-c-solution-using-dp-and-trie/
        cout << "DYNAMIC_PROGRAMMING_TRIE\n";

        sort(words.begin(), words.end(), [](const string& w1, const string& w2) {
            /* every word can be generated by concatinating smaller words only,
             * so smaller words will be processed and inserted into trie first
             */
            return (w1.size() < w2.size());
        });

        root = new trie();
        for (auto word : words) {
            int len = word.length();
            if (len == 0) {
                continue;
            }
            vector<bool> dp(len + 1, false);
            dp[0] = true;

            for (int i = 0; i < len; ++i) {
                trie* node = root;
                for (int j = i; j >= 0; --j) {
                    /* instead of keeping the smaller words into a map and
                     * searching in the map after doing substr() which is O(n) operation,
                     * trie is being used here to achieve constant time search operation of current suffix
                     */
                    if (node->arr[word[j] - 'a'] == NULL) {
                        break;
                    }

                    node = node->arr[word[j] - 'a'];
                    if (dp[j] && node->end) {
                        dp[i + 1] = true;
                        break;
                    }
                }
            }

            if (dp[len] == true) {
                retVal.push_back(word);
            }

            insert(word);
        }

        for (int i = 0; i < MAX_CHAR; ++i) {
            if (root->arr[i] != nullptr) {
                delete root->arr[i];
            }
        }
        delete root;
#endif

        return retVal;
    }
};

int main(int argc, char** argv) {
    struct subject {
        vector<string> words;
    };
    vector<subject> testData{
        {{"cat", "cats", "catsdogcats", "dog", "dogcatsdog", "hippopotamuses", "rat", "ratcatdogcat"}},
        {{"cat", "dog", "catdog"}}};
    int numberOfTestCase = testData.size();

    Solution cSolution;
    vector<string> answer;
    for (int i = 0; i < numberOfTestCase; ++i) {
        cout << "Input: words = [";
        for (long unsigned int j = 0; j < testData[i].words.size(); ++j) {
            cout << ((j == 0) ? "" : ",") << "\"" << testData[i].words[j] << "\"";
        }
        cout << "]\n";

        answer = cSolution.findAllConcatenatedWordsInADict(testData[i].words);
        cout << "Output: [";
        for (long unsigned int j = 0; j < answer.size(); ++j) {
            cout << ((j == 0) ? "" : ",") << "\"" << answer[j] << "\"";
        }
        cout << "]\n";

        cout << "\n";
    }

    return EXIT_SUCCESS;
}
