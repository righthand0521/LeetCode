#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "list.h"

/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     struct Node *next;
 *     struct Node *random;
 * };
 */
struct Node* copyRandomList(struct Node* head) {
    struct Node* pRetVal = NULL;

    if (head == NULL) {
        return pRetVal;
    }

    /* Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
     *  head
     *  +---------------+  +----------------+  +----------------+  +----------------+  +---------------+
     *  | 7 | v | next --->| 13 | v | next --->| 11 | v | next --->| 10 | v | next --->| 1 | v | next ---> NULL
     *  +-----|---------+  +------|---------+  +------|---------+  +------|---------+  +-----|---------+    ^
     *    ^   |                   |               ^   |                   |              ^   |              |
     *    |   +-------------------|---------------|---|-------------------|--------------|---|--------------+
     *    +-----------------------+               |   +-------------------|--------------+   |
     *    |                                       +-----------------------+                  |
     *    +----------------------------------------------------------------------------------+
     */
    struct Node* pCurrent = NULL;
    struct Node* pNew = NULL;

    /* create new Node that new->val = ori->val and new->next = ori->next, ori->next = new.
     *
     *           +----------------+  +----------------+  +----------------+  +----------------+  +---------------+
     *           | 7 |   | next   |  | 13 |   | next  |  | 11 |   | next  |  | 10 |   | next  |  | 1 |   | next --> NULL
     *           +-^---------|----+  +-^----------|---+  +-^----------|---+  +-^----------|---+  +-^-------------+
     *             |         |         |         |         |         |         |         |         |
     *  +----------|----+  +-v---------|----+  +-v---------|----+  +-v---------|----+  +-v---------|---+
     *  | 7 | v | next  |  | 13 | v | next  |  | 11 | v | next  |  | 10 | v | next  |  | 1 | v | next  |   NULL
     *  +-----|---------+  +------|---------+  +------|---------+  +------|---------+  +-----|---------+    ^
     *    ^   |                   |               ^   |                   |              ^   |              |
     *    |   +-------------------|---------------|---|-------------------|--------------|---|--------------+
     *    +-----------------------+               |   +-------------------|--------------+   |
     *    |                                       +-----------------------+                  |
     *    +----------------------------------------------------------------------------------+
     */
    for (pCurrent = head; pCurrent != NULL; pCurrent = pCurrent->next->next) {
        pNew = (struct Node*)malloc(sizeof(struct Node));
        if (pNew == NULL) {
            perror("malloc");
            return pRetVal;
        }
        pNew->val = pCurrent->val;
        pNew->next = pCurrent->next;
        pCurrent->next = pNew;
    }

    /* link new->random = ori->random->next
     *
     *             +-----------------------------------------------------------------------------------+
     *             |                                       +------------------------+                  |
     *             +------------------------+              |    +-------------------|--------------+   |
     *             |   +--------------------|--------------|----|-------------------|--------------|---|-------------+
     *           +-v---|----------+  +------|---------+  +-v----|---------+  +------|---------+  +-v---|---------+   v
     *  copyNew  | 7 | ^ | next   |  | 13 | ^ | next  |  | 11 | ^ | next  |  | 10 | ^ | next  |  | 1 | ^ | next --> NULL
     *           +-^---------|----+  +-^----------|---+  +-^----------|---+  +-^----------|---+  +-^-------------+
     *  head       |         |         |         |         |         |         |         |         |
     *  +----------|----+  +-v---------|----+  +-v---------|----+  +-v---------|----+  +-v---------|---+
     *  | 7 | v | next  |  | 13 | v | next  |  | 11 | v | next  |  | 10 | v | next  |  | 1 | v | next  |   NULL
     *  +-----|---------+  +------|---------+  +------|---------+  +------|---------+  +-----|---------+    ^
     *    ^   |                   |               ^   |                   |              ^   |              |
     *    |   +-------------------|---------------|---|-------------------|--------------|---|--------------+
     *    +-----------------------+               |   +-------------------|--------------+   |
     *    |                                       +-----------------------+                  |
     *    +----------------------------------------------------------------------------------+
     */
    for (pCurrent = head; pCurrent != NULL; pCurrent = pCurrent->next->next) {
        pNew = pCurrent->next;
        pNew->random = ((pCurrent->random != NULL) ? (pCurrent->random->next) : (NULL));
    }

    /* recovery new->next and ori->next
     *
     *             +----------------------------------------------------------------------------------+
     *             |                                      +------------------------+                  |
     *             +-----------------------+              |    +-------------------|--------------+   |
     *             |   +-------------------|--------------|----|-------------------|--------------|---|-------------+
     *           +-v---|----------+ +------|---------+  +-v----|---------+  +------|---------+  +-v---|---------+   v
     *  copyNew  | 7 | ^ | next --->| 13 | ^ | next --->| 11 | ^ | next --->| 10 | ^ | next --->| 1 | ^ | next --> NULL
     *           +----------------+ +----------------+  +----------------+  +----------------+  +---------------+
     *  head
     *  +---------------+  +----------------+  +----------------+  +----------------+  +---------------+
     *  | 7 | v | next --->| 13 | v | next --->| 11 | v | next --->| 10 | v | next --->| 1 | v | next --->NULL
     *  +-----|---------+  +------|---------+  +------|---------+  +------|---------+  +-----|---------+    ^
     *    ^   |                   |               ^   |                   |              ^   |              |
     *    |   +-------------------|---------------|---|-------------------|--------------|---|--------------+
     *    +-----------------------+               |   +-------------------|--------------+   |
     *    |                                       +-----------------------+                  |
     *    +----------------------------------------------------------------------------------+
     */
    pRetVal = head->next;
    for (pCurrent = head; pCurrent != NULL; pCurrent = pCurrent->next) {
        pNew = pCurrent->next;
        pCurrent->next = pCurrent->next->next;
        pNew->next = ((pNew->next != NULL) ? (pNew->next->next) : (NULL));
    }

    return pRetVal;
}

int main(int argc, char** argv) {
#define MAX_SIZE (1000)
    struct testCaseType {
        int node[MAX_SIZE];
        int nodeSize;
        int random[MAX_SIZE];
    } testCase[] = {
        {{7, 13, 11, 10, 1}, 5, {INT_MIN, 0, 4, 2, 0}}, {{1, 2}, 2, {1, 1}}, {{3, 3, 3}, 3, {INT_MIN, 0, INT_MIN}}};
    int numberOfTestCase = sizeof(testCase) / sizeof(testCase[0]);
    /* Example
     *  Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
     *  Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]
     *
     *  Input: head = [[1,1],[2,1]]
     *  Output: [[1,1],[2,1]]
     *
     *  Input: head = [[3,null],[3,0],[3,null]]
     *  Output: [[3,null],[3,0],[3,null]]
     */

    struct ListNode* pHead = NULL;
    int i, j;
    for (i = 0; i < numberOfTestCase; ++i) {
        for (j = 0; j < testCase[i].nodeSize; ++j) {
            pHead = addValueToEndListNode(pHead, testCase[i].node[j]);
        }
        printf("Input: head = [");
        printList(pHead);
        printf("]\n");

#if 0
        pHead = copyRandomList(pHead);
        printf("Output: [");
        printList(pHead);
        printf("]\n");
#endif
        printf("\n");

        freeListNode(pHead);
        pHead = NULL;
    }

    return EXIT_SUCCESS;
}
